import json
from epss.epss import EPSS
from typing import List
import datetime
from itertools import zip_longest

class ProcessResults:
    """
    A class used for processing the raw results from Trivy
 
    Attributes:
        epss (EPSS): EPSS class configuration
        scanner_results_directory (str): string representation of the directory where trivy's raw results are stored
        scanner_results_directory_processed (str): string representation of the directory of where to store the processed data
    """
    
    def __init__(self, epss: EPSS, scanner_results_directory: str = 'scanner_results_trivy_raw', scanner_results_directory_processed: str = 'scanner_results_processed') -> None:
        self.scanner_results_directory = scanner_results_directory
        self.scanner_results_directory_processed = scanner_results_directory_processed
        self.epss_instance = epss

    def process_raw_results(self, vulnerability_list_name: str) -> None:
        """
        Entry method for processing raw Trivy results
 
        Parameters:
            vulnerability_list_name (str): name of vulnerability list to be formatted
 
        Returns:
            None: writes processed vulnerability list to JSON
        """
        print('Starting processing of raw results.')
        enriched_vulnerability_list, cve_score_map = self._format_vulnerability_list(vulnerability_list_name)
        formatted_result = self.calculate_compliance_score(enriched_vulnerability_list=enriched_vulnerability_list, cve_score_map=cve_score_map)

        print(f'Writing processed values to: {self.scanner_results_directory_processed}/{vulnerability_list_name}.json')
        with open(f'{self.scanner_results_directory_processed}/{vulnerability_list_name}.json', 'w') as file:
            json.dump(formatted_result, file)
        print(f'Successfully wrote values to: {self.scanner_results_directory_processed}/{vulnerability_list_name}.json')
        print('Finished processing raw results')
    
    def calculate_compliance_score(self, flagged_severity: tuple = ('HIGH', 'CRITICAL'), flagged_status: tuple = ('fixed'), enriched_vulnerability_list: List[dict] = None, cve_score_map: dict = {}) -> dict:
        """
        Method to populate overall compliance score and provide final formatting of vulnerability list
 
        Parameters:
            flagged_severity (tuple): tuple representing severity(s) considered high risk
            flagged_status (tuple): tuple representing status which is considered high risk
            enriched_vulnerability_list (list): initial formatted vulnerability list pre score
            cve_score_map (dict): dict with mapped CVE id to EPSS score
 
        Returns:
            dict: formatted dict with compliance score, compliance status, timestamp of processing in UTC, libraries impacting compliance score, and all libraries
        """
        print('Calculating compliance score.')
        
        total_number_of_libraries = len(enriched_vulnerability_list)

        total_flagged_libraries = 0
        libraries_of_concern = []
        for vulnerabilty in enriched_vulnerability_list:
            if vulnerabilty.get('severity') in flagged_severity and vulnerabilty.get('status') in flagged_status and float(cve_score_map.get(vulnerabilty.get('vulnerability'), 0)) >= 0.50:
                total_flagged_libraries = total_flagged_libraries + 1
                vulnerabilty['score'] = cve_score_map.get(vulnerabilty.get('vulnerability'), '0')
                libraries_of_concern.append(vulnerabilty)
            vulnerabilty['score'] = cve_score_map.get(vulnerabilty.get('vulnerability'), '0')
        
        compliance_score = 100 * (1 - ((total_flagged_libraries) / total_number_of_libraries))

        if compliance_score == 100:
            compliance_status = 'Compliant'
            compliance_score_reasoning = 'Compliance score of 100%'
        elif compliance_score < 100 and compliance_score >= 90:
            compliance_status = 'Opportunity for improvement'
            compliance_score_reasoning = 'Compliance score between 90-99%'
        elif compliance_score < 90:
            compliance_status = 'Non compliant'
            compliance_score_reasoning = 'Compliance score less than 90%'
        else:
            compliance_status = 'Unknown'
            compliance_score_reasoning = 'Problem encountered during scoring'

        print('Successfully calculated compliance score.')

        return {'complianceScore': compliance_score, 'complianceScoreReasoning': compliance_score_reasoning, 'complianceStatus': compliance_status, 'timestamp': datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%f"), 'librariesImpactingScore': libraries_of_concern, 'allLibraries': enriched_vulnerability_list}
    
    def map_cve_score(self, list_of_cve_ids: List[str]) -> dict:
        """
        Method for mapping CVE id to CVE score
 
        Parameters:
            list_of_cve_ids (list): list of CVE ids and their related information from EPSS
 
        Returns:
            dict: dictionary containing mapping of CVE ID to its relevant score
        """
        list_of_cve = list(self._batch_cve_request(list_of_cve_ids, 50))
        cve_chunk_raw_values = []
        cve_dictionary = {}

        for cve_chunk in list_of_cve:
            cve_chunk_raw_values.extend(self.epss_instance.enrich_results(','.join(cve_chunk)).get('data'))
        
        self.epss_instance.session.close()
        
        for cve_value in cve_chunk_raw_values:
            cve_dictionary[cve_value.get('cve')] = cve_value.get('epss')
        
        return cve_dictionary
    
    @staticmethod
    def _batch_cve_request(cve_list: List[str], batch_size: int):
        """
        Helper method to batch list of raw CVE ID's to be called with EPSS batch endpoint
 
        Parameters:
            cve_list (list): list of CVE ids and their related information from EPSS
            batch_size (int): number of CVE id(s) in batches
 
        Returns:
            zip_longest: zip_longest object with CVE ids batched in specified size
        """
        args = [iter(cve_list)] * batch_size
        return zip_longest(*args, fillvalue='')
    
    def _format_vulnerability_list(self, vulnerability_list_name: str) -> None:
        """
        Method to initially map vulnerabilities from raw Trivy call and their relevant CVE ids
 
        Parameters:
            vulnerability_list_name (str): string name representing what raw Trivy file should be processed
 
        Returns:
            list: list of initially formatted vulnerabilities
            list: list of mapped CVE's to their scores based on the raw vulnerability list from Trivy
        """
        print('Formatting raw vulnerability list.')
        vulnerabilities = []
        cve_ids = []
        with open(f'{self.scanner_results_directory}/{vulnerability_list_name}.json') as file:
            json_data = json.load(file)

        results = json_data.get('Results')

        for result in results:
            result_list = result.get('Vulnerabilities')
            if result_list is not None:
                for vulnerability in result_list:
                    cve_ids.append(vulnerability.get('VulnerabilityID'))
                    vulnerabilities.append({'vulnerability': vulnerability.get('VulnerabilityID'), 'package_name': vulnerability.get('PkgName'), 'status': vulnerability.get('Status'), 'severity': vulnerability.get('Severity')})
     
        print('Successfully formatted raw vulnerability list.')
        return vulnerabilities, self.map_cve_score(list(set(cve_ids)))

if __name__ == '__main__':
   pass
